void heapsort(int arr[], int n) {
    // Построение max-heap (пирамиды) из исходного массива
    for (int i = n / 2 - 1; i >= 0; i--) {
        int current = i; // Текущий узел, который нужно "просеять" вниз

        while (1) {
            int largest = current; // Индекс наибольшего элемента
            int left = 2 * current + 1; // Левый потомок
            int right = 2 * current + 2; // Правый потомок

            // Проверяем, существует ли левый потомок и больше ли он текущего узла
            if (left < n && arr[left] > arr[largest]) {
                largest = left; // Обновляем индекс наибольшего элемента
            }

            // Проверяем, существует ли правый потомок и больше ли он текущего узла
            if (right < n && arr[right] > arr[largest]) {
                largest = right; // Обновляем индекс наибольшего элемента
            }

            // Если наибольший элемент не совпадает с текущим, меняем их местами
            if (largest != current) {
                int temp = arr[current];
                arr[current] = arr[largest];
                arr[largest] = temp;
                current = largest; // Продолжаем просеивать вниз
            } else {
                break; // Свойства кучи восстановлены, выходим из цикла
            }
        }
    }

    // Сортировка с использованием max-heap
    for (int i = n - 1; i >= 0; i--) {
        // Перемещаем корень (максимальный элемент) в конец неотсортированной части массива
        int temp = arr[0];
        int current = 0;
        arr[0] = arr[i];
        arr[i] = temp;

        // Восстанавливаем свойства кучи для уменьшенного массива (исключая последний элемент)
        while (1) {
            int largest = current; // Индекс наибольшего элемента
            int left = 2 * current + 1; // Левый потомок
            int right = 2 * current + 2; // Правый потомок

            // Проверяем, существует ли левый потомок в границах неотсортированной части и больше ли он текущего узла
            if (left < i && arr[left] > arr[largest]) {
                largest = left; // Обновляем индекс наибольшего элемента
            }

            // Проверяем, существует ли правый потомок в границах неотсортированной части и больше ли он текущего узла
            if (right < i && arr[right] > arr[largest]) {
                largest = right; // Обновляем индекс наибольшего элемента
            }

            // Если наибольший элемент не совпадает с текущим, меняем их местами
            if (largest != current) {
                int temp = arr[current];
                arr[current] = arr[largest];
                arr[largest] = temp;
                current = largest; // Продолжаем просеивать вниз
            } else {
                break; // Свойства кучи восстановлены, выходим из цикла
            }
        }
    }
}